plugins {
    alias(libs.plugins.fabric.loom)
    id 'java'
    id 'net.uebliche.mcmeta'
}

repositories {
    mavenCentral()
    maven { url = "https://maven.fabricmc.net/" }
}

def parseVersion = { String v ->
    v.tokenize('.+-').collect { token -> token.isInteger() ? token.toInteger() : token.toString() }
}

def resolveMinecraftVersion = { ->
    def candidates = [
            System.getenv('mcVersion'),
            project.findProperty('mcVersion'),
            project.findProperty('minecraft_version')
    ]
    candidates.find { it }?.toString()
}

def latestGameVersion = { ->
    try {
        def parsed = new groovy.json.JsonSlurper().parse(new URL("https://meta.fabricmc.net/v2/versions/game"))
        def versions = parsed.findAll { it.stable }*.version
        return versions.max { a, b ->
            def va = parseVersion(a)
            def vb = parseVersion(b)
            for (int i = 0; i < Math.max(va.size(), vb.size()); i++) {
                def ai = i < va.size() ? va[i] : 0
                def bi = i < vb.size() ? vb[i] : 0
                def cmp = ai instanceof Integer && bi instanceof Integer ? (ai <=> bi) : ai.toString() <=> bi.toString()
                if (cmp != 0) return cmp
            }
            return 0
        } ?: "1.21.11"
    } catch (Exception ignored) {
        return "1.21.11"
    }
}

def ensureMcmetaResolved = { String mcVersion ->
    def extension = project.extensions.findByName("mcmeta")
    if (extension == null) {
        throw new GradleException("mcmeta plugin not applied. Please apply net.uebliche.mcmeta.")
    }
    def current = extension.minecraftVersion?.toString()?.trim()
    if (!current || current != mcVersion) {
        extension.minecraftVersion = mcVersion
    }
    extension.resolveNow(project)
}

def resolveFabricVersions = { String game ->
    ensureMcmetaResolved(game)
    def loaderVer = project.ext.has("mcmetaFabricLoaderVersion") ? project.ext.mcmetaFabricLoaderVersion : null
    def apiVer = project.ext.has("mcmetaFabricApiVersion") ? project.ext.mcmetaFabricApiVersion : null
    if (!loaderVer) {
        throw new GradleException("mcmeta: Fabric loader version missing for Minecraft ${game}")
    }
    if (!apiVer) {
        throw new GradleException("mcmeta: Fabric API version missing for Minecraft ${game}")
    }
    return [loader: loaderVer, api: apiVer]
}

mcmeta {
    minecraftVersion = resolveMinecraftVersion() ?: ""
    repositories {
        all()
    }
}

dependencies {
    def mcVer = (resolveMinecraftVersion() ?: '1.21.11').toString()
    if (mcVer.equalsIgnoreCase('latest')) {
        mcVer = latestGameVersion() ?: '1.21.11'
    }

    def resolved = resolveFabricVersions(mcVer)
    def loaderVer = resolved.loader
    def apiVer = resolved.api

    minecraft "com.mojang:minecraft:${mcVer}"
    mappings loom.officialMojangMappings()
    modImplementation "net.fabricmc:fabric-loader:${loaderVer}"
    modImplementation "net.fabricmc.fabric-api:fabric-api:${apiVer}"
    implementation project(':common')
    implementation libs.configurate.yaml
    implementation "net.kyori:adventure-text-minimessage:4.17.0"
    implementation "net.kyori:adventure-text-serializer-gson:4.17.0"
}

loom {
    // Fabric API for 1.21.11 currently ships javadocs with intermediary names only; disable mod-provided
    // javadoc remapping to avoid Loom failures when using official mappings.
    enableModProvidedJavadoc.set(false)
    runs {
        server {
            server()
            runDir("run")
        }
    }
}

java {
    toolchain.languageVersion = JavaLanguageVersion.of(21)
}

tasks.processResources {
    inputs.property "version", project.version
    filesMatching("fabric.mod.json") {
        expand "version": project.version
    }
}

// Debug classpath if needed
tasks.named("compileJava") {
    doFirst {
        logger.lifecycle("compileJava classpath:\n${classpath.asPath}")
    }
}
